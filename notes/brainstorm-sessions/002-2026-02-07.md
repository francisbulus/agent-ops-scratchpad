# Session 002 - 2026-02-07

## Goal

- Define the simplest working AgentOps MVP that can be demoed end-to-end.

## MVP Definition (Walking Skeleton)

- One service can send agent run events (`started`, `completed`, `failed`) to an ingest API.
- Events are stored in one database table.
- Dashboard shows:
  - total runs (24h),
  - success rate (24h),
  - total estimated cost (24h),
  - latest failures list.
- Basic budget rule triggers an alert when daily cost crosses a threshold.

If these 4 things work with real data, we have a valid MVP.

## User Story (Day 1)

- As an operator, I can open one page and answer:
  - Are agents running?
  - Are they succeeding?
  - How much did we spend today?
  - What failed most recently?

## Minimum Build Scope

### Backend

- `POST /v1/events` endpoint in `services/ingest`.
- Input validation for required fields:
  - `timestamp`, `agent_id`, `workflow_id`, `status`, `latency_ms`, `cost_usd`.
- Persist to Postgres table `agent_events`.
- `GET /v1/metrics/overview` in `services/api` returning 24h aggregates.
- `GET /v1/failures/recent` returning latest failed runs.

### Frontend

- `apps/dashboard` single page with:
  - 4 KPI cards (runs, success rate, spend, avg latency),
  - one recent failures table,
  - simple "last updated" timestamp.

### Alerts

- Cron/worker checks daily spend every 5 minutes.
- If spend > configured budget threshold, send one Slack webhook message.

## Data Model (v0)

- `agent_events`
  - `id` (uuid pk)
  - `timestamp` (timestamptz)
  - `agent_id` (text)
  - `workflow_id` (text)
  - `status` (text: success|failure|started)
  - `latency_ms` (int)
  - `cost_usd` (numeric)
  - `error_type` (text nullable)
  - `trace_id` (text nullable)

## Non-Goals (Not MVP)

- Multi-provider billing reconciliation.
- Fine-grained RBAC.
- Policy simulation engine.
- Advanced anomaly detection.
- Complex tracing UI.

## Done Criteria

- Synthetic event generator can send 1,000 events and dashboard updates correctly.
- A forced failure appears in recent failures within 1 minute.
- Spend threshold test sends Slack alert once.
- Fresh deploy from README instructions works on a clean machine.

## 7-Day Plan

- Day 1: event schema + DB migration.
- Day 2: ingest endpoint + validation.
- Day 3: overview/failure query endpoints.
- Day 4: dashboard page connected to real API.
- Day 5: budget alert worker + Slack webhook.
- Day 6: synthetic load script + bug fixes.
- Day 7: polish, docs, demo script.

## Open Questions

- Keep as two Go services now, or collapse into one binary for speed?
- Is Slack the only required alert target for MVP?
- Do we need per-workspace filtering in MVP or global view only?

## Next Actions

- Freeze the v0 event schema in `packages`.
- Decide one DB migration tool and standardize it.
- Implement the first endpoint: `POST /v1/events`.

## Scratch - Platform Primitives (First Principles)

### What the platform must answer

- What work happened?
- What resources were consumed (tokens, tool calls, time)?
- What did it cost?
- Was it within policy and budget?
- If something failed, why and where?

### Core invariants

- Every billable action is tied to a traceable event.
- Token and cost accounting is reproducible from stored data.
- Budget checks happen before and/or during execution, not only after.
- Governance decisions are logged with actor, rule, and outcome.

### Primitive 1: Tenant

- Unit of ownership and spend accountability.
- Keys: `tenant_id`, `workspace_id`, `project_id`.

### Primitive 2: Run

- One end-to-end agent execution request.
- Keys: `run_id`, `agent_id`, `workflow_id`, `started_at`, `ended_at`, `status`.

### Primitive 3: Step

- A composable unit inside a run (prompt step, tool step, router step).
- Keys: `step_id`, `run_id`, `step_type`, `status`, `latency_ms`.

### Primitive 4: Model Call

- Atomic LLM invocation with measurable token usage.
- Keys: `model_call_id`, `run_id`, `step_id`, `provider`, `model`, `request_meta`.

### Primitive 5: Token Meter

- Canonical token accounting record per model call.
- Keys: `input_tokens`, `output_tokens`, `cached_tokens`, `total_tokens`.
- Rule: token counts are immutable once finalized.

### Primitive 6: Price Book

- Versioned pricing map used for cost calculation.
- Keys: `provider`, `model`, `effective_from`, `price_per_1k_input`, `price_per_1k_output`.
- Rule: cost is computed against the price-book version active at event time.

### Primitive 7: Cost Ledger

- Append-only financial facts derived from token meter + price book.
- Keys: `ledger_entry_id`, `run_id`, `model_call_id`, `amount_usd`, `currency`, `reason`.
- Rule: corrections are compensating entries, never destructive edits.

### Primitive 8: Budget

- Spend guardrails at tenant/project/agent scopes.
- Keys: `budget_id`, `scope`, `period`, `limit_usd`, `soft_or_hard`.
- Behaviors:
  - Soft limit: alert + continue.
  - Hard limit: block or require approval.

### Primitive 9: Policy Decision

- Governance checkpoint output for sensitive actions.
- Keys: `policy_decision_id`, `run_id`, `policy_id`, `decision`, `reason`, `actor`.

### Primitive 10: Alert

- Notification on threshold breach or reliability regression.
- Keys: `alert_id`, `type`, `scope`, `trigger_value`, `threshold`, `sent_at`.

### Primitive 11: Trace

- Join structure linking run -> step -> model call -> tool call -> policy decision.
- Keys: `trace_id`, `span_id`, `parent_span_id`.
- Rule: every event emitted must include trace context.

### Minimum derived metrics from primitives

- Usage: runs/day, model calls/day, tokens/day by scope.
- Cost: daily spend, cost per run, cost per successful run.
- Reliability: success rate, p95 latency, error rate by type.
- Governance: policy block rate, approvals pending, hard-budget denials.

### Minimal event contract additions (to support these primitives)

- Required fields to add/standardize:
  - `tenant_id`, `run_id`, `step_id`, `model_call_id`
  - `trace_id`, `span_id`, `parent_span_id`
  - `input_tokens`, `output_tokens`, `total_tokens`
  - `provider`, `model`, `price_book_version`, `cost_usd`
  - `budget_scope`, `budget_result`
  - `policy_id`, `policy_decision`

### Immediate implementation implication

- Even for MVP, keep three stores logically separate:
  - Event store (operational truth),
  - Cost ledger (financial truth),
  - Metrics aggregates (query speed).
